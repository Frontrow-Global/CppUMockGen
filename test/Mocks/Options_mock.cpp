/*
 * This file has been auto-generated by CppUMockGen v0.6.
 *
 * Only contents in the user code section will be preserved if it is regenerated!!!
 *
 * Generation options: -t "#const std::string &=String~$.c_str()" -t "@std::string=String"
 */

#include "Options.hpp"

#include <CppUTestExt/MockSupport.h>

// CPPUMOCKGEN_USER_CODE_BEGIN
// CPPUMOCKGEN_USER_CODE_END

Options::Options()
: m_options( "", "" )
{
    mock().actualCall("Options::Options");
}

void Options::Parse(int argc, const char * argv[])
{
    mock().actualCall("Options::Parse").onObject(this).withIntParameter("argc", argc).withPointerParameter("argv", argv);
}

void Options::Parse(const std::string & options)
{
    mock().actualCall("Options::Parse").onObject(this).withStringParameter("options", options.c_str());
}

bool Options::IsHelpRequested() const
{
    return mock().actualCall("Options::IsHelpRequested").onObject(this).returnBoolValue();
}

std::string Options::GetHelpText() const
{
    return mock().actualCall("Options::GetHelpText").onObject(this).returnStringValue();
}

bool Options::IsVersionRequested() const
{
    return mock().actualCall("Options::IsVersionRequested").onObject(this).returnBoolValue();
}

std::string Options::GetInputPath() const
{
    return mock().actualCall("Options::GetInputPath").onObject(this).returnStringValue();
}

std::string Options::GetBaseDirectory() const
{
    return mock().actualCall("Options::GetBaseDirectory").onObject(this).returnStringValue();
}

bool Options::IsMockRequested() const
{
    return mock().actualCall("Options::IsMockRequested").onObject(this).returnBoolValue();
}

std::string Options::GetMockOutputPath() const
{
    return mock().actualCall("Options::GetMockOutputPath").onObject(this).returnStringValue();
}

bool Options::IsExpectationsRequested() const
{
    return mock().actualCall("Options::IsExpectationsRequested").onObject(this).returnBoolValue();
}

std::string Options::GetExpectationsOutputPath() const
{
    return mock().actualCall("Options::GetExpectationsOutputPath").onObject(this).returnStringValue();
}

bool Options::IsRegenerationRequested() const
{
    return mock().actualCall("Options::IsRegenerationRequested").onObject(this).returnBoolValue();
}

bool Options::InterpretAsCpp() const
{
    return mock().actualCall("Options::InterpretAsCpp").onObject(this).returnBoolValue();
}

std::string Options::GetLanguageStandard() const
{
    return mock().actualCall("Options::GetLanguageStandard").onObject(this).returnStringValue();
}

bool Options::UseUnderlyingTypedef() const
{
    return mock().actualCall("Options::UseUnderlyingTypedef").onObject(this).returnBoolValue();
}

std::vector<std::string> Options::GetTypeOverrides() const
{
    return *static_cast<const std::vector<std::string>*>(mock().actualCall("Options::GetTypeOverrides").onObject(this).returnConstPointerValue());
}

std::vector<std::string> Options::GetIncludePaths() const
{
    return *static_cast<const std::vector<std::string>*>(mock().actualCall("Options::GetIncludePaths").onObject(this).returnConstPointerValue());
}

std::string Options::GetGenerationOptions() const
{
    return mock().actualCall("Options::GetGenerationOptions").onObject(this).returnStringValue();
}

