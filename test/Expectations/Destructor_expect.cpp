/*
 * This file has been auto-generated by CppUMockGen v0.5.
 *
 * Contents will NOT be preserved if it is regenerated!!!
 *
 * Generation options: -t "#const CXCursor &=ConstPointer~&$" -t "@std::string=String" -t "#const std::string &=String~$.c_str()"
 */

#include "Destructor_expect.hpp"

namespace expect { namespace Destructor$ {
MockExpectedCall& Destructor$ctor()
{
    return Destructor$ctor(1);
}
MockExpectedCall& Destructor$ctor(unsigned int __numCalls__)
{
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "Destructor::Destructor");
    return __expectedCall__;
}
} }

namespace expect { namespace Destructor$ {
MockExpectedCall& IsMockable(CppUMockGen::Parameter<const Destructor*> __object__, CppUMockGen::Parameter<const void*> cursor, bool __return__)
{
    return IsMockable(1, __object__, cursor, __return__);
}
MockExpectedCall& IsMockable(unsigned int __numCalls__, CppUMockGen::Parameter<const Destructor*> __object__, CppUMockGen::Parameter<const void*> cursor, bool __return__)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "Destructor::IsMockable");
    if(!__object__.isIgnored()) { __expectedCall__.onObject(const_cast<Destructor*>(__object__.getValue())); }
    if(cursor.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withConstPointerParameter("cursor", cursor.getValue()); }
    __expectedCall__.andReturnValue(__return__);
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
} }

namespace expect { namespace Destructor$ {
MockExpectedCall& GetExpectationFunctionName(CppUMockGen::Parameter<const Destructor*> __object__, CppUMockGen::Parameter<const char*> functionName, const char* __return__)
{
    return GetExpectationFunctionName(1, __object__, functionName, __return__);
}
MockExpectedCall& GetExpectationFunctionName(unsigned int __numCalls__, CppUMockGen::Parameter<const Destructor*> __object__, CppUMockGen::Parameter<const char*> functionName, const char* __return__)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "Destructor::GetExpectationFunctionName");
    if(!__object__.isIgnored()) { __expectedCall__.onObject(const_cast<Destructor*>(__object__.getValue())); }
    if(functionName.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withStringParameter("functionName", functionName.getValue()); }
    __expectedCall__.andReturnValue(__return__);
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
} }

