/*
 * This file has been auto-generated by CppUTestMock v0.3.0.
 *
 * Contents will NOT be preserved if it is regenerated!!!
 *
 * Generation options: -t "#const std::string &=String/$.c_str()" -t "#const CXCursor &=ConstPointer/&$" -t "#const Config &=ConstPointer/&$" -t @std::string=String 
 */

#include "Function_expect.hpp"

namespace expect { namespace Function$ {
MockExpectedCall& Parse(CppUMockGen::Parameter<const Function*> __object__, CppUMockGen::Parameter<const void*> cursor, CppUMockGen::Parameter<const void*> config, bool __return__)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectOneCall("Function::Parse");
    if(!__object__.isIgnored()) { __expectedCall__.onObject(const_cast<Function*>(__object__.getValue())); }
    if(cursor.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withConstPointerParameter("cursor", cursor.getValue()); }
    if(config.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withConstPointerParameter("config", config.getValue()); }
    __expectedCall__.andReturnValue(__return__);
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
MockExpectedCall& Parse(unsigned int __numCalls__, CppUMockGen::Parameter<const Function*> __object__, CppUMockGen::Parameter<const void*> cursor, CppUMockGen::Parameter<const void*> config, bool __return__)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "Function::Parse");
    if(!__object__.isIgnored()) { __expectedCall__.onObject(const_cast<Function*>(__object__.getValue())); }
    if(cursor.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withConstPointerParameter("cursor", cursor.getValue()); }
    if(config.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withConstPointerParameter("config", config.getValue()); }
    __expectedCall__.andReturnValue(__return__);
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
} }

namespace expect { namespace Function$ {
MockExpectedCall& GenerateMock(CppUMockGen::Parameter<const Function*> __object__, const char* __return__)
{
    MockExpectedCall& __expectedCall__ = mock().expectOneCall("Function::GenerateMock");
    if(!__object__.isIgnored()) { __expectedCall__.onObject(const_cast<Function*>(__object__.getValue())); }
    __expectedCall__.andReturnValue(__return__);
    return __expectedCall__;
}
MockExpectedCall& GenerateMock(unsigned int __numCalls__, CppUMockGen::Parameter<const Function*> __object__, const char* __return__)
{
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "Function::GenerateMock");
    if(!__object__.isIgnored()) { __expectedCall__.onObject(const_cast<Function*>(__object__.getValue())); }
    __expectedCall__.andReturnValue(__return__);
    return __expectedCall__;
}
} }

namespace expect { namespace Function$ {
MockExpectedCall& GenerateExpectation(CppUMockGen::Parameter<const Function*> __object__, CppUMockGen::Parameter<bool> proto, const char* __return__)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectOneCall("Function::GenerateExpectation");
    if(!__object__.isIgnored()) { __expectedCall__.onObject(const_cast<Function*>(__object__.getValue())); }
    if(proto.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withBoolParameter("proto", proto.getValue()); }
    __expectedCall__.andReturnValue(__return__);
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
MockExpectedCall& GenerateExpectation(unsigned int __numCalls__, CppUMockGen::Parameter<const Function*> __object__, CppUMockGen::Parameter<bool> proto, const char* __return__)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "Function::GenerateExpectation");
    if(!__object__.isIgnored()) { __expectedCall__.onObject(const_cast<Function*>(__object__.getValue())); }
    if(proto.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withBoolParameter("proto", proto.getValue()); }
    __expectedCall__.andReturnValue(__return__);
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
} }

namespace expect { namespace Function$ {
MockExpectedCall& IsMockable(CppUMockGen::Parameter<const Function*> __object__, CppUMockGen::Parameter<const void*> cursor, bool __return__)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectOneCall("Function::IsMockable");
    if(!__object__.isIgnored()) { __expectedCall__.onObject(const_cast<Function*>(__object__.getValue())); }
    if(cursor.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withConstPointerParameter("cursor", cursor.getValue()); }
    __expectedCall__.andReturnValue(__return__);
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
MockExpectedCall& IsMockable(unsigned int __numCalls__, CppUMockGen::Parameter<const Function*> __object__, CppUMockGen::Parameter<const void*> cursor, bool __return__)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "Function::IsMockable");
    if(!__object__.isIgnored()) { __expectedCall__.onObject(const_cast<Function*>(__object__.getValue())); }
    if(cursor.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withConstPointerParameter("cursor", cursor.getValue()); }
    __expectedCall__.andReturnValue(__return__);
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
} }

