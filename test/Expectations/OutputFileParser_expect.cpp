/*
 * This file has been auto-generated by CppUMockGen v0.6.
 *
 * Contents will NOT be preserved if it is regenerated!!!
 *
 * Generation options: -s c++17 -t "#const std::string &=String~$.c_str()" -t "#const std::filesystem::path &=String~$.generic_string().c_str()"
 */

#include "OutputFileParser_expect.hpp"

namespace expect { namespace OutputFileParser$ {
MockExpectedCall& OutputFileParser$ctor()
{
    return OutputFileParser$ctor(1);
}
MockExpectedCall& OutputFileParser$ctor(unsigned int __numCalls__)
{
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "OutputFileParser::OutputFileParser");
    return __expectedCall__;
}
} }

namespace expect { namespace OutputFileParser$ {
MockExpectedCall& Parse(CppUMockGen::Parameter<const OutputFileParser*> __object__, CppUMockGen::Parameter<const char*> filepath)
{
    return Parse(1, __object__, filepath);
}
MockExpectedCall& Parse(unsigned int __numCalls__, CppUMockGen::Parameter<const OutputFileParser*> __object__, CppUMockGen::Parameter<const char*> filepath)
{
    bool __ignoreOtherParams__ = false;
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "OutputFileParser::Parse");
    if(!__object__.isIgnored()) { __expectedCall__.onObject(const_cast<OutputFileParser*>(__object__.getValue())); }
    if(filepath.isIgnored()) { __ignoreOtherParams__ = true; } else { __expectedCall__.withStringParameter("filepath", filepath.getValue()); }
    if(__ignoreOtherParams__) { __expectedCall__.ignoreOtherParameters(); }
    return __expectedCall__;
}
} }

namespace expect { namespace OutputFileParser$ {
MockExpectedCall& GetUserCode(CppUMockGen::Parameter<const OutputFileParser*> __object__, const std::string * __return__)
{
    return GetUserCode(1, __object__, __return__);
}
MockExpectedCall& GetUserCode(unsigned int __numCalls__, CppUMockGen::Parameter<const OutputFileParser*> __object__, const std::string * __return__)
{
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "OutputFileParser::GetUserCode");
    if(!__object__.isIgnored()) { __expectedCall__.onObject(const_cast<OutputFileParser*>(__object__.getValue())); }
    __expectedCall__.andReturnValue(static_cast<const void*>(__return__));
    return __expectedCall__;
}
} }

namespace expect { namespace OutputFileParser$ {
MockExpectedCall& GetGenerationOptions(CppUMockGen::Parameter<const OutputFileParser*> __object__, const std::string * __return__)
{
    return GetGenerationOptions(1, __object__, __return__);
}
MockExpectedCall& GetGenerationOptions(unsigned int __numCalls__, CppUMockGen::Parameter<const OutputFileParser*> __object__, const std::string * __return__)
{
    MockExpectedCall& __expectedCall__ = mock().expectNCalls(__numCalls__, "OutputFileParser::GetGenerationOptions");
    if(!__object__.isIgnored()) { __expectedCall__.onObject(const_cast<OutputFileParser*>(__object__.getValue())); }
    __expectedCall__.andReturnValue(static_cast<const void*>(__return__));
    return __expectedCall__;
}
} }

